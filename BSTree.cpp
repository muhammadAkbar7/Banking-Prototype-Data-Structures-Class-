#include "BSTree.h"//----------------------------------------------------------------------------// Constructor// Constructor for BSTree classBSTree::BSTree() {	root = NULL;}//----------------------------------------------------------------------------// Destructor // Destructor for BSTree classBSTree::~BSTree() {	makeEmpty();}//----------------------------------------------------------------------------// makeEmpty// makes the BSTree tree emptyvoid BSTree::makeEmpty() {	makeEmpty(root);}//----------------------------------------------------------------------------// makeEmpty// helper method for make Empty. Takes a node "root" as a parameter// and  uses that as a guide to empty out the treevoid BSTree::makeEmpty(Node* & traverse) { //node* not reading	if (traverse != nullptr) {		makeEmpty(traverse->left);		makeEmpty(traverse->right);		delete traverse;	}	traverse = nullptr;}//----------------------------------------------------------------------------// retrieve// Takes a const Client& "target" and Client& "search" to see if the target// Client object is found in the BSTree. Returns true if so and false if notbool BSTree::retrieve(const Client& target, Client*& search) const { //helper method?, left, right, node*    Node* temp = root;    return retrieveHelp(target, search, temp);}//----------------------------------------------------------------------------// retrieveHelp// Helper method for the retrieve. Takes a const Client& "target", // Client& "search"// and Node* "temp" as parameters. Returns true if "target" is found in BSTree, // otherwise returns false. bool BSTree::retrieveHelp(const Client& target, Client*& point, Node* temp) const {    if (temp == nullptr) {        point = nullptr;        return false;    } else if (*temp->data == target) {        point = temp->data;        return true;    } else if (*temp->data > target) {        return (retrieveHelp(target, point, temp->left));    } else {        return (retrieveHelp(target, point, temp->right));    }}//----------------------------------------------------------------------------bool BSTree::isEmpty() const{    return root == nullptr;}void BSTree::display() const {    displayHelp(root);    cout << endl}void BSTree::displayHelp(Node* print) const{ // node* not reading    if (print != nullptr) {        displayHelp(print->left);        cout << print->data << " ";        displayHelp(print->right);    }}bool BSTree::insert(Client* dataptr) { //gotta compare    Node* ptr = new Node;    if (ptr == NULL) return false;            // out of memory    ptr->data = dataptr;    ptr->left = ptr->right = NULL;    if (isEmpty()) {        root = ptr;    }    else {        Node* current = root;                           // walking pointer        bool inserted = false;                          // whether inserted yet        // if item is less than current item, insert in left subtree,        // otherwise insert in right subtree        while (!inserted) {            if (*ptr->data < *current->data) { //make a comparison funtion                if (current->left == NULL) {              // insert left                    current->left = ptr;                    inserted = true;                }                else                    current = current->left;               // one step left            }            else {                if (current->right == NULL) {             // insert right                    current->right = ptr;                    inserted = true;                }                else                    current = current->right;              // one step right            }        }    }    return true;}